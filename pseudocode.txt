pseudocode.txt


Pieces:

CLASS Piece:
    INITIALIZE(color, symbol_char): // symbol_char is 'P', 'R', 'N', 'B', 'Q', 'K'
        self.color = color // "white" or "black"
        self.base_symbol = symbol_char // Store the uppercase base symbol
        self.has_moved = False // Important for Pawns, Kings, Rooks (though latter two are for castling, not in prototype)

    METHOD get_symbol():
        IF self.color == "white":
            RETURN self.base_symbol
        ELSE:
            RETURN self.base_symbol.lower()

    // Abstract method - to be implemented by subclasses
    // start_pos, end_pos are (row, col) tuples
    // is_capture_intent: boolean, true if notation was 'exd5', false for 'd5'
    METHOD is_valid_move_pattern(start_pos, end_pos, is_capture_intent):
        RAISE NotImplementedError // Subclasses must implement this

    METHOD is_slider(): // Helper to know if path clearing is needed
        RETURN False // Default, overridden by Rook, Bishop, Queen

CLASS Pawn INHERITS Piece:
    INITIALIZE(color):
        CALL super.INITIALIZE(color, 'P')

    METHOD is_valid_move_pattern(start_pos, end_pos, is_capture_intent):
        start_row, start_col = start_pos
        end_row, end_col = end_pos
        dr = end_row - start_row
        dc = end_col - start_col

        IF self.color == "white":
            direction = -1 // Moves from row 6 towards row 0
        ELSE: // black
            direction = 1  // Moves from row 1 towards row 7

        // Forward one square
        IF NOT is_capture_intent AND dc == 0 AND dr == direction:
            RETURN True // Target square must be empty (checked by Game)

        // Forward two squares (initial move)
        IF NOT is_capture_intent AND dc == 0 AND dr == 2 * direction AND NOT self.has_moved:
            RETURN True // Path must be clear & target empty (checked by Game)

        // Capture
        IF is_capture_intent AND abs(dc) == 1 AND dr == direction:
            RETURN True // Target square must have opponent (checked by Game)

        RETURN False

    // Pawns are sliders only on their initial two-square move,
    // which is handled by path checking in Game if this method returns True for that case.
    // For simplicity, we can treat path clearing specifically for this case in Game.

CLASS Rook INHERITS Piece:
    INITIALIZE(color):
        CALL super.INITIALIZE(color, 'R')

    METHOD is_valid_move_pattern(start_pos, end_pos, is_capture_intent): // is_capture_intent mostly ignored by non-pawns
        start_row, start_col = start_pos
        end_row, end_col = end_pos
        dr = end_row - start_row
        dc = end_col - start_col

        RETURN (dr == 0 AND dc != 0) OR (dr != 0 AND dc == 0)

    METHOD is_slider():
        RETURN True

CLASS Knight INHERITS Piece:
    INITIALIZE(color):
        CALL super.INITIALIZE(color, 'N')

    METHOD is_valid_move_pattern(start_pos, end_pos, is_capture_intent):
        start_row, start_col = start_pos
        end_row, end_col = end_pos
        dr = abs(end_row - start_row)
        dc = abs(end_col - start_col)

        RETURN (dr == 2 AND dc == 1) OR (dr == 1 AND dc == 2)

    // is_slider() remains False (Knights jump)

CLASS Bishop INHERITS Piece:
    INITIALIZE(color):
        CALL super.INITIALIZE(color, 'B')

    METHOD is_valid_move_pattern(start_pos, end_pos, is_capture_intent):
        start_row, start_col = start_pos
        end_row, end_col = end_pos
        dr = abs(end_row - start_row)
        dc = abs(end_col - start_col)

        RETURN dr == dc AND dr != 0 // dr != 0 ensures it's not the same square

    METHOD is_slider():
        RETURN True

CLASS Queen INHERITS Piece:
    INITIALIZE(color):
        CALL super.INITIALIZE(color, 'Q')

    METHOD is_valid_move_pattern(start_pos, end_pos, is_capture_intent):
        start_row, start_col = start_pos
        end_row, end_col = end_pos
        abs_dr = abs(end_row - start_row)
        abs_dc = abs(end_col - start_col)

        is_rook_move = (abs_dr == 0 AND abs_dc != 0) OR (abs_dr != 0 AND abs_dc == 0)
        is_bishop_move = (abs_dr == abs_dc AND abs_dr != 0)

        RETURN is_rook_move OR is_bishop_move

    METHOD is_slider():
        RETURN True

CLASS King INHERITS Piece:
    INITIALIZE(color):
        CALL super.INITIALIZE(color, 'K')

    METHOD is_valid_move_pattern(start_pos, end_pos, is_capture_intent):
        start_row, start_col = start_pos
        end_row, end_col = end_pos
        abs_dr = abs(end_row - start_row)
        abs_dc = abs(end_col - start_col)

        RETURN abs_dr <= 1 AND abs_dc <= 1 AND (abs_dr != 0 OR abs_dc != 0) // Not staying in place

    // is_slider() remains False


——————————————————————————————

Board:

// Assumed: Internal coordinates (row, col) are 0-indexed.
// Row 0 is Rank 8, Row 7 is Rank 1.
// Col 0 is File 'a', Col 7 is File 'h'.

CLASS Board:
    INITIALIZE():
        self.grid = CREATE 8x8 array (list of lists) initialized with None

    METHOD setup_pieces(piece_module): // piece_module provides access to Pawn, Rook etc. classes
        // Example: piece_module.Rook('white')
        // White pieces (Rank 1 = row 7, Rank 2 = row 6)
        self.grid[7][0] = piece_module.Rook("white")
        self.grid[7][1] = piece_module.Knight("white")
        self.grid[7][2] = piece_module.Bishop("white")
        self.grid[7][3] = piece_module.Queen("white")
        self.grid[7][4] = piece_module.King("white")
        self.grid[7][5] = piece_module.Bishop("white")
        self.grid[7][6] = piece_module.Knight("white")
        self.grid[7][7] = piece_module.Rook("white")
        FOR col FROM 0 TO 7:
            self.grid[6][col] = piece_module.Pawn("white")

        // Black pieces (Rank 8 = row 0, Rank 7 = row 1)
        self.grid[0][0] = piece_module.Rook("black")
        self.grid[0][1] = piece_module.Knight("black")
        // ... and so on for other black pieces
        self.grid[0][7] = piece_module.Rook("black")
        FOR col FROM 0 TO 7:
            self.grid[1][col] = piece_module.Pawn("black")

    METHOD display_board():
        PRINT "  a b c d e f g h"
        PRINT "  -----------------"
        FOR r FROM 0 TO 7: // r=0 (Rank 8) to r=7 (Rank 1)
            PRINT (8 - r) + "|", end_char=""
            FOR c FROM 0 TO 7:
                piece = self.grid[r][c]
                IF piece IS NOT None:
                    PRINT piece.get_symbol() + " ", end_char=""
                ELSE:
                    PRINT ". ", end_char="" // Or "  " for cleaner look if cells are aligned
            PRINT "|" + (8 - r)
        PRINT "  -----------------"
        PRINT "  a b c d e f g h"

    METHOD get_piece(row, col):
        IF self.is_valid_square(row, col):
            RETURN self.grid[row][col]
        RETURN None

    METHOD set_piece(row, col, piece):
        IF self.is_valid_square(row, col):
            self.grid[row][col] = piece

    METHOD move_piece(start_pos, end_pos):
        start_row, start_col = start_pos
        end_row, end_col = end_pos
        piece_to_move = self.get_piece(start_row, start_col)
        IF piece_to_move IS NOT None:
            self.set_piece(end_row, end_col, piece_to_move)
            self.set_piece(start_row, start_col, None)
            IF piece_to_move.base_symbol == 'P' OR piece_to_move.base_symbol == 'K' OR piece_to_move.base_symbol == 'R':
                 piece_to_move.has_moved = True // Mark as moved

    METHOD algebraic_to_coords(alg_square_str): // e.g., "e4"
        IF LENGTH(alg_square_str) != 2: RETURN None
        file_char = alg_square_str[0]
        rank_char = alg_square_str[1]

        IF 'a' <= file_char <= 'h' AND '1' <= rank_char <= '8':
            col = ASCII_VALUE(file_char) - ASCII_VALUE('a')
            row = 8 - INTEGER(rank_char)
            RETURN (row, col)
        RETURN None

    METHOD coords_to_algebraic(row, col):
        IF NOT self.is_valid_square(row, col): RETURN None
        file_char = CHARACTER(ASCII_VALUE('a') + col)
        rank_char = STRING(8 - row)
        RETURN file_char + rank_char

    METHOD is_valid_square(row, col):
        RETURN 0 <= row <= 7 AND 0 <= col <= 7

    METHOD is_path_clear(start_pos, end_pos):
        // Assumes move is Rook-like, Bishop-like or Pawn's 2-square initial move.
        // Knights do not call this.
        start_row, start_col = start_pos
        end_row, end_col = end_pos

        dr = end_row - start_row
        dc = end_col - start_col

        step_r = 0 IF dr == 0 ELSE dr / ABS(dr) // -1, 0, or 1
        step_c = 0 IF dc == 0 ELSE dc / ABS(dc) // -1, 0, or 1

        current_r, current_c = start_row + step_r, start_col + step_c

        WHILE (current_r, current_c) != (end_row, end_col):
            IF NOT self.is_valid_square(current_r, current_c): // Should not happen if move pattern is valid
                RETURN False // Safety check
            IF self.grid[current_r][current_c] IS NOT None:
                RETURN False // Path is blocked
            current_r += step_r
            current_c += step_c
        RETURN True



——————————————————————————————

Gameplay:

// IMPORT Board from board
// IMPORT * AS pieces_module from pieces // (Pawn, Rook, etc.)

CLASS Game:
    INITIALIZE():
        self.board = Board()
        self.board.setup_pieces(pieces_module)
        self.current_player = "white"
        self.game_over = False
        // No need for explicit piece_classes_map if using pieces_module directly.

    METHOD switch_player():
        IF self.current_player == "white":
            self.current_player = "black"
        ELSE:
            self.current_player = "white"

    // Simplified Algebraic Notation Parser for Prototype:
    // Piece (optional) + target_square (e.g., "e4", "Nf3", "exd5")
    // For pawn moves like "exd5", it implies piece 'P', capture 'x', source file 'e', target 'd5'.
    METHOD parse_algebraic_move(move_str):
        move_str = move_str.strip()
        parsed = {'piece_char': 'P', 'target_sq_alg': None, 'is_capture': False, 'dis_file': None, 'dis_rank': None}

        // Check for piece character (N, B, R, Q, K)
        IF move_str[0] IS_UPPERCASE AND move_str[0] IN "NBRQK":
            parsed['piece_char'] = move_str[0]
            move_str = move_str[1:]

        // Check for capture 'x'
        IF 'x' IN move_str:
            parsed['is_capture'] = True
            parts = move_str.split('x')
            // If pawn capture like "exd5", parts[0] is 'e' (disambiguation file)
            // If piece capture like "Nxd5", parts[0] could be 'b' (disambiguation) or empty.
            IF parsed['piece_char'] == 'P' AND LENGTH(parts[0]) == 1 AND 'a' <= parts[0] <= 'h':
                parsed['dis_file'] = parts[0]
            ELIF LENGTH(parts[0]) == 1 AND ('a' <= parts[0] <= 'h' OR '1' <= parts[0] <= '8'): // Disambiguation char
                IF 'a' <= parts[0] <= 'h':
                    parsed['dis_file'] = parts[0]
                ELSE:
                    parsed['dis_rank'] = parts[0]
            move_str = parts[1] // The part after 'x' is the target square
        
        // What remains should be the target square (e.g., "e4")
        // Or could be disambiguation + target square (e.g. "bd2" if piece was 'N', becomes "d2" with dis_file 'b')
        IF LENGTH(move_str) == 2 AND 'a' <= move_str[0] <= 'h' AND '1' <= move_str[1] <= '8':
            parsed['target_sq_alg'] = move_str
        ELIF LENGTH(move_str) == 3 AND parsed['piece_char'] != 'P': // e.g. Nbd2, R1e4
            // Check if first char is disambiguation
            dis_char = move_str[0]
            target_candidate = move_str[1:]
            IF 'a' <= target_candidate[0] <= 'h' AND '1' <= target_candidate[1] <= '8':
                 IF 'a' <= dis_char <= 'h':
                    parsed['dis_file'] = dis_char
                 ELIF '1' <= dis_char <= '8':
                    parsed['dis_rank'] = dis_char
                 ELSE: RETURN None // Invalid disambiguation
                 parsed['target_sq_alg'] = target_candidate
            ELSE: RETURN None // Invalid format after disambiguation
        ELSE:
            RETURN None // Invalid target square format

        IF parsed['target_sq_alg'] IS None: RETURN None
        RETURN parsed


    METHOD find_source_square_for_move(parsed_move_data):
        piece_char_to_find = parsed_move_data['piece_char']
        target_alg = parsed_move_data['target_sq_alg']
        target_coords = self.board.algebraic_to_coords(target_alg)
        IF target_coords IS None: RETURN None

        is_capture_intent = parsed_move_data['is_capture']
        dis_file = parsed_move_data['dis_file']
        dis_rank = parsed_move_data['dis_rank']

        candidate_sources = []
        FOR r FROM 0 TO 7:
            FOR c FROM 0 TO 7:
                piece = self.board.get_piece(r, c)
                IF piece IS NOT None AND piece.color == self.current_player AND piece.base_symbol == piece_char_to_find:
                    // Apply disambiguation if present
                    current_alg_file = self.board.coords_to_algebraic(r,c)[0]
                    current_alg_rank = self.board.coords_to_algebraic(r,c)[1]
                    IF dis_file IS NOT None AND current_alg_file != dis_file:
                        CONTINUE // Skip this piece, doesn't match disambiguation file
                    IF dis_rank IS NOT None AND current_alg_rank != dis_rank:
                        CONTINUE // Skip this piece, doesn't match disambiguation rank

                    start_pos = (r, c)
                    IF self.is_move_internally_consistent(piece, start_pos, target_coords, is_capture_intent):
                        candidate_sources.ADD(start_pos)
        
        IF LENGTH(candidate_sources) == 1:
            RETURN candidate_sources[0]
        ELSE:
            // Ambiguous or no legal move found from any piece of this type
            // For prototype, we might simplify and not require full ambiguity resolution if only one piece *can* move.
            // But strict algebraic notation expects an error if it's ambiguous and not disambiguated by user.
            RETURN None


    METHOD is_move_internally_consistent(piece, start_pos, end_pos, is_capture_intent_from_parser):
        // This method checks if a piece *could* make the move, considering its pattern, path, and target square occupation.
        // It's used by find_source_square_for_move.

        // 1. Check piece's basic movement pattern
        IF NOT piece.is_valid_move_pattern(start_pos, end_pos, is_capture_intent_from_parser):
            RETURN False

        // 2. Check target square validity (not capturing own piece)
        target_piece = self.board.get_piece(end_pos[0], end_pos[1])
        IF target_piece IS NOT None AND target_piece.color == self.current_player:
            RETURN False // Cannot move to a square occupied by own piece

        // 3. Check pawn-specific rules for capture/non-capture based on intent
        IF piece.base_symbol == 'P':
            IF is_capture_intent_from_parser: // e.g., "exd5"
                IF target_piece IS None OR target_piece.color == self.current_player:
                    RETURN False // Capture intent, but target is empty or own piece
            ELSE: // e.g., "e4"
                IF target_piece IS NOT None:
                    RETURN False // Non-capture intent, but target is occupied
        ELSE: // Non-pawn pieces
            IF is_capture_intent_from_parser:
                IF target_piece IS None OR target_piece.color == self.current_player:
                     // This implies algebraic notation like "Nxe4" but e4 is empty or friendly.
                     // Some engines allow "Ne4" even if it's a capture. For prototype, be strict.
                     RETURN False 
            // IF NOT is_capture_intent_from_parser AND target_piece IS NOT None AND target_piece.color != self.current_player:
            //     This is a valid capture even if 'x' was omitted (e.g. "Ne4" captures).
            //     The `is_capture_intent_from_parser` is more about parsing and pawn diagonal.

        // 4. Check path clearance for sliders (Rook, Bishop, Queen)
        // And for Pawn's 2-square initial move
        is_pawn_two_step = (piece.base_symbol == 'P' AND
                            abs(end_pos[0] - start_pos[0]) == 2 AND
                            NOT is_capture_intent_from_parser)
        
        IF piece.is_slider() OR is_pawn_two_step:
            IF NOT self.board.is_path_clear(start_pos, end_pos):
                RETURN False

        RETURN True // All checks passed for this piece to make this move

    METHOD play():
        WHILE NOT self.game_over:
            self.board.display_board()
            PRINT f"{self.current_player.capitalize()}'s turn."
            move_input = INPUT("Enter move (e.g., e4, Nf3, exd5, Nbc3) or 'quit': ")

            IF move_input.lower() == "quit":
                self.game_over = True
                PRINT "Game resigned."
                CONTINUE

            parsed_move = self.parse_algebraic_move(move_input)
            IF parsed_move IS None:
                PRINT "Invalid move format. Try again."
                CONTINUE

            target_coords_alg = parsed_move['target_sq_alg']
            target_coords = self.board.algebraic_to_coords(target_coords_alg)
            IF target_coords IS None OR NOT self.board.is_valid_square(target_coords[0], target_coords[1]):
                PRINT f"Invalid target square: {target_coords_alg}. Try again."
                CONTINUE
            
            source_coords = self.find_source_square_for_move(parsed_move)

            IF source_coords IS None:
                PRINT "Illegal or ambiguous move. Try again."
                CONTINUE
            ELSE:
                // Make the move
                self.board.move_piece(source_coords, target_coords)
                // Pawn promotion would go here - not in prototype
                self.switch_player()
                // Check/Checkmate/Stalemate detection would go here - not in prototype

        PRINT "Game over."


——————————————————————————————


main:

// IMPORT Game from gameplay

FUNCTION main_game_loop():
    game_instance = Game()
    game_instance.play()

IF THIS_FILE_IS_EXECUTED_DIRECTLY: // __name__ == "__main__"
    PRINT "Starting Chess Prototype..."
    main_game_loop()
    PRINT "Exiting Chess Prototype."